{"version":3,"file":"JsonLdParser.js","sourceRoot":"","sources":["JsonLdParser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from \"@rdfjs/types\";\n// tslint:disable-next-line:no-var-requires\nconst Parser = require('@bergos/jsonparse');\nimport {ERROR_CODES, ErrorCoded, IDocumentLoader, JsonLdContext, Util as ContextUtil} from \"jsonld-context-parser\";\nimport {PassThrough, Transform, Readable} from \"readable-stream\";\nimport {EntryHandlerArrayValue} from \"./entryhandler/EntryHandlerArrayValue\";\nimport {EntryHandlerContainer} from \"./entryhandler/EntryHandlerContainer\";\nimport {EntryHandlerInvalidFallback} from \"./entryhandler/EntryHandlerInvalidFallback\";\nimport {EntryHandlerPredicate} from \"./entryhandler/EntryHandlerPredicate\";\nimport {IEntryHandler} from \"./entryhandler/IEntryHandler\";\nimport {EntryHandlerKeywordContext} from \"./entryhandler/keyword/EntryHandlerKeywordContext\";\nimport {EntryHandlerKeywordGraph} from \"./entryhandler/keyword/EntryHandlerKeywordGraph\";\nimport {EntryHandlerKeywordId} from \"./entryhandler/keyword/EntryHandlerKeywordId\";\nimport {EntryHandlerKeywordIncluded} from \"./entryhandler/keyword/EntryHandlerKeywordIncluded\";\nimport EventEmitter = NodeJS.EventEmitter;\nimport {EntryHandlerKeywordNest} from \"./entryhandler/keyword/EntryHandlerKeywordNest\";\nimport {EntryHandlerKeywordType} from \"./entryhandler/keyword/EntryHandlerKeywordType\";\nimport {EntryHandlerKeywordUnknownFallback} from \"./entryhandler/keyword/EntryHandlerKeywordUnknownFallback\";\nimport {EntryHandlerKeywordValue} from \"./entryhandler/keyword/EntryHandlerKeywordValue\";\nimport {ParsingContext} from \"./ParsingContext\";\nimport {Util} from \"./Util\";\nimport {parse as parseLinkHeader} from \"http-link-header\";\nimport { EntryHandlerKeywordAnnotation } from './entryhandler/keyword/EntryHandlerKeywordAnnotation';\n\n/**\n * A stream transformer that parses JSON-LD (text) streams to an {@link RDF.Stream}.\n */\nexport class JsonLdParser extends Transform implements RDF.Sink<EventEmitter, RDF.Stream> {\n\n  public static readonly DEFAULT_PROCESSING_MODE: string = '1.1';\n  public static readonly ENTRY_HANDLERS: IEntryHandler<any>[] = [\n    new EntryHandlerArrayValue(),\n    new EntryHandlerKeywordContext(),\n    new EntryHandlerKeywordId(),\n    new EntryHandlerKeywordIncluded(),\n    new EntryHandlerKeywordGraph(),\n    new EntryHandlerKeywordNest(),\n    new EntryHandlerKeywordType(),\n    new EntryHandlerKeywordValue(),\n    new EntryHandlerKeywordAnnotation(),\n    new EntryHandlerContainer(),\n    new EntryHandlerKeywordUnknownFallback(),\n    new EntryHandlerPredicate(),\n    new EntryHandlerInvalidFallback(),\n  ];\n\n  private readonly options: IJsonLdParserOptions;\n  private readonly parsingContext: ParsingContext;\n  private readonly util: Util;\n\n  private readonly jsonParser: any;\n  // Jobs that are not started yet that process a @context (only used if streamingProfile is false)\n  private readonly contextJobs: (() => Promise<void>)[][];\n  // Jobs that are not started yet that process a @type (only used if streamingProfile is false)\n  private readonly typeJobs: { job: () => Promise<void>, keys: string[] }[];\n  // Jobs that are not started yet because of a missing @context or @type (only used if streamingProfile is false)\n  private readonly contextAwaitingJobs: { job: () => Promise<void>, keys: string[]; depth: number }[];\n\n  // The last depth that was processed.\n  private lastDepth: number;\n  // The last keys that were processed.\n  private lastKeys: any[];\n  // A promise representing the last job\n  private lastOnValueJob: Promise<void>;\n\n  constructor(options?: IJsonLdParserOptions) {\n    super({ readableObjectMode: true });\n    options = options || {};\n    this.options = options;\n    this.parsingContext = new ParsingContext({ parser: this, ...options });\n    this.util = new Util({ dataFactory: options.dataFactory, parsingContext: this.parsingContext });\n\n    this.jsonParser = new Parser();\n    this.contextJobs = [];\n    this.typeJobs = [];\n    this.contextAwaitingJobs = [];\n\n    this.lastDepth = 0;\n    this.lastKeys = [];\n    this.lastOnValueJob = Promise.resolve();\n\n    this.attachJsonParserListeners();\n\n    this.on('end', () => {\n      if (typeof this.jsonParser.mode !== 'undefined') {\n        this.emit('error', new Error('Unclosed document'))\n      }\n    })\n  }\n\n  /**\n   * Construct a JsonLdParser from the given HTTP response.\n   *\n   * This will throw an error if no valid JSON response is received\n   * (application/ld+json, application/json, or something+json).\n   *\n   * For raw JSON responses, exactly one link header pointing to a JSON-LD context is required.\n   *\n   * This method is not responsible for handling redirects.\n   *\n   * @param baseIRI The URI of the received response.\n   * @param mediaType The received content type.\n   * @param headers Optional HTTP headers.\n   * @param options Optional parser options.\n   */\n  public static fromHttpResponse(baseIRI: string, mediaType: string,\n                                 headers?: Headers, options?: IJsonLdParserOptions): JsonLdParser {\n    let context: JsonLdContext | undefined;\n    // Special cases when receiving something else than the JSON-LD media type\n    if (mediaType !== 'application/ld+json') {\n      // Only accept JSON or JSON extension types\n      if (mediaType !== 'application/json' && !mediaType.endsWith('+json')) {\n        throw new ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`,\n          ERROR_CODES.LOADING_DOCUMENT_FAILED);\n      }\n\n      // We need exactly one JSON-LD context in the link header\n      if (headers && headers.has('Link')) {\n        headers.forEach((value, key) => {\n          if (key === 'link') {\n            const linkHeader = parseLinkHeader(value);\n            for (const link of linkHeader.get('rel', 'http://www.w3.org/ns/json-ld#context')) {\n              if (context) {\n                throw new ErrorCoded('Multiple JSON-LD context link headers were found on ' + baseIRI,\n                  ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);\n              }\n              context = link.uri;\n            }\n          }\n        });\n      }\n      if (!context && !options?.ignoreMissingContextLinkHeader) {\n        throw new ErrorCoded(`Missing context link header for media type ${mediaType} on ${baseIRI}`,\n          ERROR_CODES.LOADING_DOCUMENT_FAILED);\n      }\n    }\n\n    // Check if the streaming profile is present\n    let streamingProfile: boolean | undefined;\n    if (headers && headers.has('Content-Type')) {\n      const contentType = <string> headers.get('Content-Type');\n      const match = /; *profile=([^\"]*)/.exec(contentType);\n      if (match && match[1] === 'http://www.w3.org/ns/json-ld#streaming') {\n        streamingProfile = true;\n      }\n    }\n\n    return new JsonLdParser({\n      baseIRI,\n      context,\n      streamingProfile,\n      ... options ? options : {},\n    });\n  }\n\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n  public import(stream: EventEmitter): RDF.Stream {\n    if('pipe' in stream) {\n      stream.on('error', (error) => parsed.emit('error', error));\n      const parsed = (<Readable>stream).pipe(new JsonLdParser(this.options));\n      return parsed;\n    } else {\n      const output = new PassThrough({ readableObjectMode: true });\n      stream.on('error', (error) => parsed.emit('error', error));\n      stream.on('data', (data) => output.push(data));\n      stream.on('end', () => output.push(null));\n      const parsed = output.pipe(new JsonLdParser(this.options));\n      return parsed;\n    }\n  }\n\n  public _transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    this.jsonParser.write(chunk);\n    this.lastOnValueJob\n      .then(() => callback(), (error) => callback(error));\n  }\n\n  /**\n   * Start a new job for parsing the given value.\n   *\n   * This will let the first valid {@link IEntryHandler} handle the entry.\n   *\n   * @param {any[]} keys The stack of keys.\n   * @param value The value to parse.\n   * @param {number} depth The depth to parse at.\n   * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n   * @return {Promise<void>} A promise resolving when the job is done.\n   */\n  public async newOnValueJob(keys: any[], value: any, depth: number, lastDepthCheck: boolean) {\n    let flushStacks: boolean = true;\n\n    // When we go up the stack, emit all unidentified values\n    // We need to do this before the new job, because the new job may require determined values from the flushed jobs.\n    if (lastDepthCheck && depth < this.lastDepth) {\n      // Check if we had any RDF lists that need to be terminated with an rdf:nil\n      const listPointer = this.parsingContext.listPointerStack[this.lastDepth];\n      if (listPointer) {\n        // Terminate the list if the had at least one value\n        if (listPointer.value) {\n          this.push(this.util.dataFactory.quad(listPointer.value, this.util.rdfRest, this.util.rdfNil,\n            this.util.getDefaultGraph()));\n        }\n\n        // Add the list id to the id stack, so it can be used higher up in the stack\n        (<any> listPointer.listId).listHead = true;\n        this.parsingContext.idStack[listPointer.listRootDepth + 1] = [ listPointer.listId ];\n\n        this.parsingContext.listPointerStack.splice(this.lastDepth, 1);\n      }\n\n      // Flush the buffer for lastDepth\n      // If the parent key is a special type of container, postpone flushing until that parent is handled.\n      if (await EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth)) {\n        this.parsingContext.pendingContainerFlushBuffers\n          .push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) });\n        flushStacks = false;\n      } else {\n        await this.flushBuffer(this.lastDepth, this.lastKeys);\n      }\n    }\n\n    const key = await this.util.unaliasKeyword(keys[depth], keys, depth);\n    const parentKey = await this.util.unaliasKeywordParent(keys, depth);\n    this.parsingContext.emittedStack[depth] = true;\n    let handleKey = true;\n\n    // Keywords inside @reverse is not allowed apart from @context\n    if (ContextUtil.isValidKeyword(key) && parentKey === '@reverse' && key !== '@context') {\n      this.emit('error', new ErrorCoded(`Found the @id '${value}' inside an @reverse property`,\n          ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));\n    }\n\n    // Skip further processing if one of the parent nodes are invalid.\n    // We use the validationStack to reuse validation results that were produced before with common key stacks.\n    let inProperty: boolean = false;\n    if (this.parsingContext.validationStack.length > 1) {\n      inProperty = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property;\n    }\n    for (let i = Math.max(1, this.parsingContext.validationStack.length - 1); i < keys.length - 1; i++) {\n      const validationResult = this.parsingContext.validationStack[i]\n        || (this.parsingContext.validationStack[i] = await this.validateKey(keys.slice(0, i + 1), i, inProperty));\n      if (!validationResult.valid) {\n        this.parsingContext.emittedStack[depth] = false;\n        handleKey = false;\n        break;\n      } else if (!inProperty && validationResult.property) {\n        inProperty = true;\n      }\n    }\n\n    // Skip further processing if this node is part of a literal\n    if (await this.util.isLiteral(keys, depth)) {\n      handleKey = false;\n    }\n\n    // Get handler\n    if (handleKey) {\n      for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n        const testResult = await entryHandler.test(this.parsingContext, this.util, key, keys, depth);\n        if (testResult) {\n          // Pass processing over to the handler\n          await entryHandler.handle(this.parsingContext, this.util, key, keys, value, depth, testResult);\n\n          // Flag that this depth is processed\n          if (entryHandler.isStackProcessor()) {\n            this.parsingContext.processingStack[depth] = true;\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Validate value indexes on the root.\n    if (depth === 0 && Array.isArray(value)) {\n      await this.util.validateValueIndexes(value);\n    }\n\n    // When we go up the stack, flush the old stack\n    if (flushStacks && depth < this.lastDepth) {\n      // Reset our stacks\n      this.flushStacks(this.lastDepth);\n    }\n    this.lastDepth = depth;\n    this.lastKeys = keys;\n\n    // Clear the keyword cache at this depth, and everything underneath.\n    this.parsingContext.unaliasedKeywordCacheStack.splice(depth - 1);\n  }\n\n  /**\n   * Flush the processing stacks at the given depth.\n   * @param {number} depth A depth.\n   */\n  public flushStacks(depth: number) {\n    this.parsingContext.processingStack.splice(depth, 1);\n    this.parsingContext.processingType.splice(depth, 1);\n    this.parsingContext.emittedStack.splice(depth, 1);\n    this.parsingContext.idStack.splice(depth, 1);\n    this.parsingContext.graphStack.splice(depth + 1, 1);\n    this.parsingContext.graphContainerTermStack.splice(depth, 1);\n    this.parsingContext.jsonLiteralStack.splice(depth, 1);\n    this.parsingContext.validationStack.splice(depth - 1, 2);\n    this.parsingContext.literalStack.splice(depth, this.parsingContext.literalStack.length - depth);\n    this.parsingContext.annotationsBuffer.splice(depth, 1);\n    // TODO: just like the literal stack, splice all other stack until the end as well?\n  }\n\n  /**\n   * Flush buffers for the given depth.\n   *\n   * This should be called after the last entry at a given depth was processed.\n   *\n   * @param {number} depth A depth.\n   * @param {any[]} keys A stack of keys.\n   * @return {Promise<void>} A promise resolving if flushing is done.\n   */\n  public async flushBuffer(depth: number, keys: any[]) {\n    let subjects: RDF.Term[] = this.parsingContext.idStack[depth];\n    const subjectsWasDefined = !!subjects;\n    if (!subjectsWasDefined) {\n      subjects = this.parsingContext.idStack[depth] = [ this.util.dataFactory.blankNode() ];\n    }\n\n    // Flush values at this level\n    const valueBuffer: { predicate: RDF.Term, object: RDF.Term, reverse: boolean, isEmbedded: boolean }[] =\n      this.parsingContext.unidentifiedValuesBuffer[depth];\n    if (valueBuffer) {\n      for (const subject of subjects) {\n        const depthOffsetGraph = await this.util.getDepthOffsetGraph(depth, keys);\n        const graphs: RDF.Term[] = (this.parsingContext.graphStack[depth] || depthOffsetGraph >= 0)\n          ? this.parsingContext.idStack[depth - depthOffsetGraph - 1]\n          : [ await this.util.getGraphContainerValue(keys, depth) ];\n        if (graphs) {\n          for (const graph of graphs) {\n            // Flush values to stream if the graph @id is known\n            this.parsingContext.emittedStack[depth] = true;\n            for (const bufferedValue of valueBuffer) {\n              this.util.emitQuadChecked(depth, subject, bufferedValue.predicate, bufferedValue.object, graph, bufferedValue.reverse, bufferedValue.isEmbedded);\n            }\n          }\n        } else {\n          // Place the values in the graphs buffer if the graph @id is not yet known\n          const subGraphBuffer = this.parsingContext.getUnidentifiedGraphBufferSafe(\n            depth - await this.util.getDepthOffsetGraph(depth, keys) - 1);\n          for (const bufferedValue of valueBuffer) {\n            if (bufferedValue.reverse) {\n              subGraphBuffer.push({\n                object: subject,\n                predicate: bufferedValue.predicate,\n                subject: bufferedValue.object,\n                isEmbedded: bufferedValue.isEmbedded,\n              });\n            } else {\n              subGraphBuffer.push({\n                object: bufferedValue.object,\n                predicate: bufferedValue.predicate,\n                subject,\n                isEmbedded: bufferedValue.isEmbedded,\n              });\n            }\n          }\n        }\n      }\n      this.parsingContext.unidentifiedValuesBuffer.splice(depth, 1);\n      this.parsingContext.literalStack.splice(depth, 1);\n      this.parsingContext.jsonLiteralStack.splice(depth, 1);\n    }\n\n    // Flush graphs at this level\n    const graphBuffer: { subject: RDF.Term, predicate: RDF.Term, object: RDF.Term }[] =\n      this.parsingContext.unidentifiedGraphsBuffer[depth];\n    if (graphBuffer) {\n      for (const subject of subjects) {\n        // A @graph statement at the root without @id relates to the default graph,\n        // unless there are top-level properties,\n        // others relate to blank nodes.\n        const graph: RDF.Term = depth === 1 && subject.termType === 'BlankNode'\n        && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : subject;\n        this.parsingContext.emittedStack[depth] = true;\n        for (const bufferedValue of graphBuffer) {\n          this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(\n            bufferedValue.subject, bufferedValue.predicate, bufferedValue.object, graph));\n        }\n      }\n      this.parsingContext.unidentifiedGraphsBuffer.splice(depth, 1);\n    }\n\n    // Push unhandled annotations up the stack as nested annotations\n    const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];\n    if (annotationsBuffer) {\n      // Throw an error if we reach the top, and still have annotations\n      if (annotationsBuffer.length > 0 && depth === 1) {\n        this.parsingContext.emitError(new ErrorCoded(`Annotations can not be made on top-level nodes`,\n          ERROR_CODES.INVALID_ANNOTATION));\n      }\n\n      // Pass the annotations buffer up one level in the stack\n      const annotationsBufferParent = this.parsingContext.getAnnotationsBufferSafe(depth - 1);\n      for (const annotation of annotationsBuffer) {\n        annotationsBufferParent.push(annotation);\n      }\n      delete this.parsingContext.annotationsBuffer[depth];\n    }\n  }\n\n  /**\n   * Check if at least one {@link IEntryHandler} validates the entry to true.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth A depth.\n   * @param {boolean} inProperty If the current depth is part of a valid property node.\n   * @return {Promise<{ valid: boolean, property: boolean }>} A promise resolving to true or false.\n   */\n  protected async validateKey(keys: any[], depth: number, inProperty: boolean)\n    : Promise<{ valid: boolean, property: boolean }> {\n    for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n      if (await entryHandler.validate(this.parsingContext, this.util, keys, depth, inProperty)) {\n        return { valid: true, property: inProperty || entryHandler.isPropertyHandler() };\n      }\n    }\n    return { valid: false, property: false };\n  }\n\n  /**\n   * Attach all required listeners to the JSON parser.\n   *\n   * This should only be called once.\n   */\n  protected attachJsonParserListeners() {\n    // Listen to json parser events\n    this.jsonParser.onValue = (value: any) => {\n      const depth = this.jsonParser.stack.length;\n      const keys = (new Array(depth + 1).fill(0)).map((v, i) => {\n        return i === depth ? this.jsonParser.key : this.jsonParser.stack[i].key;\n      });\n\n      if (!this.isParsingContextInner(depth)) { // Don't parse inner nodes inside @context\n        const valueJobCb = () => this.newOnValueJob(keys, value, depth, true);\n        if (!this.parsingContext.streamingProfile\n          && !this.parsingContext.contextTree.getContext(keys.slice(0, -1))) {\n          // If an out-of-order context is allowed,\n          // we have to buffer everything.\n          // We store jobs for @context's and @type's separately,\n          // because at the end, we have to process them first.\n          // We also handle @type because these *could* introduce a type-scoped context.\n          if (keys[depth] === '@context') {\n            let jobs = this.contextJobs[depth];\n            if (!jobs) {\n              jobs = this.contextJobs[depth] = [];\n            }\n            jobs.push(valueJobCb);\n          } else {\n            this.contextAwaitingJobs.push({ job: valueJobCb, keys, depth });\n          }\n        } else {\n          // Make sure that our value jobs are chained synchronously\n          this.lastOnValueJob = this.lastOnValueJob.then(valueJobCb);\n        }\n\n        // Execute all buffered jobs on deeper levels\n        if (!this.parsingContext.streamingProfile && depth === 0) {\n          this.lastOnValueJob = this.lastOnValueJob\n            .then(() => this.executeBufferedJobs());\n        }\n      }\n    };\n    this.jsonParser.onError = (error: Error) => {\n      this.emit('error', error);\n    };\n  }\n\n  /**\n   * Check if the parser is currently parsing an element that is part of an @context entry.\n   * @param {number} depth A depth.\n   * @return {boolean} A boolean.\n   */\n  protected isParsingContextInner(depth: number) {\n    for (let i = depth; i > 0; i--) {\n      if (this.jsonParser.stack[i - 1].key === '@context') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Execute all buffered jobs.\n   * @return {Promise<void>} A promise resolving if all jobs are finished.\n   */\n  protected async executeBufferedJobs() {\n    // Handle context jobs\n    for (const jobs of this.contextJobs) {\n      if (jobs) {\n        for (const job of jobs) {\n          await job();\n        }\n      }\n    }\n\n    // Clear the keyword cache.\n    this.parsingContext.unaliasedKeywordCacheStack.splice(0);\n\n    const contextAwaitingJobs: { job: () => Promise<void>, keys: string[]; depth: number }[] = [];\n\n    for (const job of this.contextAwaitingJobs) {\n      if ((await this.util.unaliasKeyword(job.keys[job.depth], job.keys, job.depth, true)) === '@type'\n      || typeof job.keys[job.depth] === 'number' && (await this.util.unaliasKeyword(job.keys[job.depth - 1], job.keys, job.depth - 1, true)) === '@type') { // Also capture @type with array values\n        // Remove @type from keys, because we want it to apply to parent later on\n        this.typeJobs.push({ job: job.job, keys: job.keys.slice(0, job.keys.length - 1) })\n      } else {\n        contextAwaitingJobs.push(job)\n      }\n    }\n\n    // Handle non-context jobs\n    for (const job of contextAwaitingJobs) {\n      // Check if we have a type (with possible type-scoped context) that should be handled before.\n      // We check all possible parent nodes for the current job, from root to leaves.\n      if (this.typeJobs.length > 0) {\n        // First collect all applicable type jobs\n        const applicableTypeJobs: { job: () => Promise<void>, keys: string[] }[] = [];\n        const applicableTypeJobIds: number[] = [];\n        for (let i = 0; i < this.typeJobs.length; i++) {\n          const typeJob = this.typeJobs[i];\n          if (Util.isPrefixArray(typeJob.keys, job.keys)) {\n            applicableTypeJobs.push(typeJob);\n            applicableTypeJobIds.push(i);\n          }\n        }\n\n        // Next, sort the jobs from short to long key length (to ensure types higher up in the tree to be handled first)\n        const sortedTypeJobs = applicableTypeJobs.sort((job1, job2) => job1.keys.length - job2.keys.length);\n\n        // Finally, execute the jobs in order\n        for (const typeJob of sortedTypeJobs) {\n          await typeJob.job();\n        }\n\n        // Remove the executed type jobs\n        // Sort first, so we can efficiently splice\n        const sortedApplicableTypeJobIds = applicableTypeJobIds.sort().reverse();\n        for (const jobId of sortedApplicableTypeJobIds) {\n          this.typeJobs.splice(jobId, 1);\n        }\n      }\n\n      await job.job();\n    }\n  }\n}\n\n/**\n * Constructor arguments for {@link JsonLdParser}\n */\nexport interface IJsonLdParserOptions {\n  /**\n   * A data factory.\n   */\n  dataFactory?: RDF.DataFactory<RDF.BaseQuad>;\n  /**\n   * The root context.\n   */\n  context?: JsonLdContext;\n  /**\n   * The base IRI.\n   */\n  baseIRI?: string;\n  /**\n   * If this parser can assume that parsed documents follow the streaming JSON-LD profile.\n   * If true, and a non-streaming document is detected, an error may be thrown.\n   * If false, non-streaming documents will be handled by preemptively buffering entries,\n   * which will lose many of the streaming benefits of this parser.\n   *\n   * Concretely, if true, @context definitions must come as first object entries,\n   * followed by @type (if they define a type-scoped context).\n   *\n   * Defaults to false for spec-compliance.\n   */\n  streamingProfile?: boolean;\n  /**\n   * Loader for remote contexts.\n   */\n  documentLoader?: IDocumentLoader;\n  /**\n   * If the lack of JSON-LD context link headers on raw JSON documents should NOT result in an error.\n   * If true, raw JSON documents can be considered first-class JSON-LD documents.\n   */\n  ignoreMissingContextLinkHeader?: boolean;\n  /**\n   * If blank node predicates should be allowed,\n   * they will be ignored otherwise.\n   * Defaults to false.\n   */\n  produceGeneralizedRdf?: boolean;\n  /**\n   * The maximum JSON-LD version that should be processable by this parser.\n   * Defaults to JsonLdParser.DEFAULT_PROCESSING_MODE.\n   */\n  processingMode?: string;\n  /**\n   * By default, JSON-LD requires that\n   * all properties (or @id's) that are not URIs,\n   * are unknown keywords,\n   * and do not occur in the context\n   * should be silently dropped.\n   * When setting this value to true,\n   * an error will be thrown when such properties occur.\n   *\n   * This also applies to invalid values such as language tags.\n   *\n   * Defaults to false.\n   */\n  strictValues?: boolean;\n  /**\n   * If RDF lists can appear in the subject position.\n   * Defaults to false.\n   */\n  allowSubjectList?: boolean;\n  /**\n   * If @index inside array nodes should be validated.\n   * I.e., nodes inside the same array with the same @id,\n   * should have equal @index values.\n   * This is not applicable to this parser as we don't do explicit flattening,\n   * but it is required to be spec-compliant.\n   * Defaults to false.\n   *\n   * Spec-compliance: to be fully spec-compliant,\n   * this must be explicitly set to true.\n   */\n  validateValueIndexes?: boolean;\n  /**\n   * The graph to use as default graph when no explicit @graph is set.\n   * Defaults to dataFactory.defaultGraph().\n   */\n  defaultGraph?: RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph;\n  /**\n   * The mode by which the values with a certain base direction should be transformed into RDF.\n   * * 'i18n-datatype': objects have a https://www.w3.org/ns/i18n# datatype.\n   * * 'compound-literal': reified values using rdf:value, rdf:direction and rdf:language.\n   */\n  rdfDirection?: 'i18n-datatype' | 'compound-literal';\n  /**\n   * If language tags should be normalized to lowercase.\n   * This is always true for JSON-LD 1.0,\n   * but false by default for all following versions.\n   */\n  normalizeLanguageTags?: boolean;\n  /**\n   * When the streaming profile flag is enabled,\n   * `@type` entries MUST come before other properties since they may defined a type-scoped context.\n   * However, when this flag is enabled, `@type` entries that do NOT\n   * define a type-scoped context may appear anywhere just like a regular property.\n   */\n  streamingProfileAllowOutOfOrderPlainType?: boolean;\n  /**\n   * If JSON-LD context validation should be skipped.\n   *\n   * This is useful when parsing large contexts that are known to be valid.\n   */\n  skipContextValidation?: boolean;\n  /**\n   * If embedded nodes and annotated objects should be parsed according to the JSON-LD star specification.\n   * Defaults to true\n   */\n  rdfstar?: boolean;\n  /**\n   * If embedded nodes may use reverse properties\n   * Defaults to false.\n   */\n  rdfstarReverseInEmbedded?: boolean;\n}\n"]}