{"version":3,"file":"EntryHandlerKeywordType.js","sourceRoot":"","sources":["EntryHandlerKeywordType.ts"],"names":[],"mappings":"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","sourcesContent":["import {ERROR_CODES, ErrorCoded, JsonLdContextNormalized} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../../ParsingContext\";\nimport {Util} from \"../../Util\";\nimport {EntryHandlerPredicate} from \"../EntryHandlerPredicate\";\nimport {EntryHandlerKeyword} from \"./EntryHandlerKeyword\";\n\n/**\n * Handles @graph entries.\n */\nexport class EntryHandlerKeywordType extends EntryHandlerKeyword {\n\n  constructor() {\n    super('@type');\n  }\n\n  public isStackProcessor(): boolean {\n    return false;\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    const keyOriginal = keys[depth];\n\n    // The current identifier identifies an rdf:type predicate.\n    // But we only emit it once the node closes,\n    // as it's possible that the @type is used to identify the datatype of a literal, which we ignore here.\n    const context = await parsingContext.getContext(keys);\n    const predicate = util.rdfType;\n    const parentKey = await util.unaliasKeywordParent(keys, depth);\n    const reverse = Util.isPropertyReverse(context, keyOriginal, parentKey);\n    const isEmbedded = Util.isPropertyInEmbeddedNode(parentKey);\n    util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);\n    const isAnnotation = Util.isPropertyInAnnotationObject(parentKey);\n\n    // Handle multiple values if the value is an array\n    const elements = Array.isArray(value) ? value : [ value ];\n    for (const element of elements) {\n      if (typeof element !== 'string') {\n        parsingContext.emitError(new ErrorCoded(`Found illegal @type '${element}'`, ERROR_CODES.INVALID_TYPE_VALUE));\n      }\n      const type = util.createVocabOrBaseTerm(context, element);\n      if (type) {\n        await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth,\n          predicate, type, reverse, isEmbedded, isAnnotation);\n      }\n    }\n\n    // Collect type-scoped contexts if they exist\n    let scopedContext: Promise<JsonLdContextNormalized> = Promise.resolve(context);\n    let hasTypedScopedContext = false;\n    for (const element of elements.sort()) { // Spec requires lexicographical ordering\n      const typeContext = Util.getContextValue(context, '@context', element, null);\n      if (typeContext) {\n        hasTypedScopedContext = true;\n        scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));\n      }\n    }\n\n    // Error if an out-of-order type-scoped context was found when support is not enabled.\n    if (parsingContext.streamingProfile\n      && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType)\n      && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {\n      parsingContext.emitError(\n        new ErrorCoded('Found an out-of-order type-scoped context, while streaming is enabled.' +\n          '(disable `streamingProfile`)', ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n    }\n\n    // If at least least one type-scoped context applies, set them in the tree.\n    if (hasTypedScopedContext) {\n      // Do not propagate by default\n      scopedContext = scopedContext.then((c) => {\n        if (!('@propagate' in c.getContextRaw())) {\n          c.getContextRaw()['@propagate'] = false;\n        }\n\n        // Set the original context at this depth as a fallback\n        // This is needed when a context was already defined at the given depth,\n        // and this context needs to remain accessible from child nodes when propagation is disabled.\n        if (c.getContextRaw()['@propagate'] === false) {\n          c.getContextRaw()['@__propagateFallback'] = context.getContextRaw();\n        }\n\n        return c;\n      });\n\n      // Set the new context in the context tree\n      parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);\n    }\n\n    // Flag that type has been processed at this depth\n    parsingContext.processingType[depth] = true;\n  }\n\n}\n"]}